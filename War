using System;
using System.Collections.Generic;
using System.Threading;

namespace Tasks_IJunior_02._06_OOP
{
    internal class War
    {
        public static void Main(string[] args)
        {
            Battle battle = new Battle();
            battle.StartBattle();
        }
    }

    public class Battle
    {
        private Army _elvesArmy = new Army("Армия эльфов");
        private Army _orcsArmy = new Army("Армия орков");

        public void StartBattle()
        {
            List<Fighter> elvesFighters = _elvesArmy.GetFighters();
            List<Fighter> orcsFighters = _orcsArmy.GetFighters();

            ShowState(elvesFighters, orcsFighters);
            Fight(elvesFighters, orcsFighters);
        }

        private void Fight(List<Fighter> elvesFighters, List<Fighter> orcsFighters)
        {
            Console.WriteLine("Началось новое сражение!");
            string nameElves = _elvesArmy.Name;
            string nameOrcs = _orcsArmy.Name;

            while (elvesFighters.Count > 0 && orcsFighters.Count > 0)
            {
                Console.WriteLine($"Аттакует {nameElves}");
                Attack(elvesFighters, orcsFighters);

                if (orcsFighters.Count > 0)
                {
                    Console.WriteLine($"Аттакует {nameOrcs}");
                    Attack(orcsFighters, elvesFighters);
                }

                ShowState(elvesFighters, orcsFighters);
            }

            DetermineWinner(elvesFighters, orcsFighters);
        }

        private void Attack(List<Fighter> attackingFighters, List<Fighter> defendingFighters)
        {
            int attackingIndex = UserUtils.GenerateRandomNumber(attackingFighters.Count);
            Fighter attackingFighter = attackingFighters[attackingIndex];

            Console.WriteLine($"{attackingFighter.GetType().Name} атакует");

            bool attackerWins = attackingFighter.Attack(defendingFighters);

            if (attackerWins)
            {
                Console.WriteLine($"{attackingFighter.GetType().Name} победил");
            }
            else
            {
                Console.WriteLine($"{attackingFighter.GetType().Name} проиграл");
            }
        }

        private void DetermineWinner(List<Fighter> elvesFighters, List<Fighter> orcsFighters)
        {
            int minimumHealth = 0;

            if (elvesFighters.Count == orcsFighters.Count)
            {
                Console.WriteLine("Ничья!");
            }
            else if (elvesFighters.Count > minimumHealth && orcsFighters.Count == minimumHealth)
            {
                Console.WriteLine($"Победила армия эльфов!");
            }
            else if (orcsFighters.Count > minimumHealth && elvesFighters.Count == minimumHealth)
            {
                Console.WriteLine($"Победила армия орков!");
            }
        }

        private void ShowState(List<Fighter> elvesFighters, List<Fighter> orcsFighters)
        {
            Console.WriteLine($"Количество бойцов эльфов: {elvesFighters.Count}");
            Console.WriteLine($"Количество бойцов орков: {orcsFighters.Count}");
        }
    }

    public class Army
    {
        private List<Fighter> _army;
        private List<Fighter> _fighterTypes;

        public Army(string name)
        {
            Name = name;
            _army = new List<Fighter>();
            InitializeFighterTypes();
            FillArmy(_army);
        }

        public string Name { get; private set; }

        public List<Fighter> GetFighters() => new List<Fighter>(_army);

        public void FillArmy(List<Fighter> army)
        {
            int minimumNumberFighters = 5;
            int maximumNumberFighters = 10;

            int numberOfFighters = UserUtils.GenerateRandomNumbers(minimumNumberFighters, maximumNumberFighters);

            for (int i = 0; i < numberOfFighters; i++)
            {
                int randomIndex = UserUtils.GenerateRandomNumber(_fighterTypes.Count);
                Fighter fighter = _fighterTypes[randomIndex].Clone();
                army.Add(fighter);
            }
        }

        private void InitializeFighterTypes()
        {
            _fighterTypes = new List<Fighter>
            {
                new FightersNumberOne(),
                new FightersNumberTwo(),
                new FightersNumberThree(),
                new FightersNumberFour()
            };
        }
    }

    public class FightersNumberOne : Fighter
    {
        public FightersNumberOne() : base(100, 10) { }

        public override Fighter Clone()
        {
            return new FightersNumberOne();
        }

        public override string GetName()
        {
            return "Первый - обычный солдат, без особенностей";
        }

        public override bool Attack(List<Fighter> enemySoldiers)
        {
            return base.Attack(enemySoldiers);
        }
    }

    public class FightersNumberTwo : Fighter
    {
        public FightersNumberTwo() : base(50, 30) { }

        public override Fighter Clone()
        {
            return new FightersNumberTwo();
        }

        public override string GetName()
        {
            return "Второй - атакует только одного, но с множителем урона";

        }

        public override bool Attack(List<Fighter> enemySoldiers)
        {
            int opponentIndex = UserUtils.GenerateRandomNumber(enemySoldiers.Count);
            Fighter opponent = enemySoldiers[opponentIndex];

            int twoDamage = 2;
            int damageDealt = GenerateRandomDamage() * twoDamage;
            int randomArmorPenetration = GenerateRandomDamage();
            int totalDamage = damageDealt + randomArmorPenetration;

            opponent.TakeDamage(damageDealt, randomArmorPenetration);
            Console.WriteLine($"Нанесен урон {totalDamage}!");
            Thread.Sleep(2000);

            if (opponent.Health <= 0)
            {
                enemySoldiers.Remove(opponent);
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    public class FightersNumberThree : Fighter
    {
        public FightersNumberThree() : base(70, 40) { }

        public override Fighter Clone()
        {
            return new FightersNumberThree();
        }

        public override string GetName()
        {
            return "Третий - атакует сразу нескольких, без повторения атакованного за свою атаку";
        }

        public override bool Attack(List<Fighter> enemySoldiers)
        {
            var targets = new HashSet<Fighter>();

            int randomDamage = GenerateRandomDamage();
            int randomArmorPenetration = GenerateRandomDamage();
            int totalDamage = randomDamage + randomArmorPenetration;
            int maximumTargets = 3;

            for (int i = 0; i < maximumTargets; i++)
            {
                var targetIndex = UserUtils.GenerateRandomNumber(enemySoldiers.Count);
                var target = enemySoldiers[targetIndex];

                if (targets.Add(target) == false)

                    i--;
            }

            foreach (var target in targets)
            {
                target.TakeDamage(randomDamage, randomArmorPenetration);
                Console.WriteLine($"Нанесен урон {totalDamage}!");
                Thread.Sleep(2000);

                if (target.Health <= 0)
                {
                    enemySoldiers.Remove(target);
                }
            }

            if (targets.Count <= 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    public class FightersNumberFour : Fighter
    {
        public FightersNumberFour() : base(90, 20) { }

        public override Fighter Clone()
        {
            return new FightersNumberFour();
        }

        public override string GetName()
        {
            return "Четвертый - атакует сразу нескольких, атакованные солдаты могут повторяться";
        }

        public override bool Attack(List<Fighter> enemySoldiers)
        {
            int randomDamage = GenerateRandomDamage();
            int randomArmorPenetration = GenerateRandomDamage();

            bool anyEnemyDefeated = false;

            for (int i = enemySoldiers.Count - 1; i >= 0; i--)
            {
                var target = enemySoldiers[i];

                target.TakeDamage(randomDamage, randomArmorPenetration);
                Console.WriteLine($"Нанесен урон {randomDamage}!");
                Thread.Sleep(2000);

                if (target.Health <= 0)
                {
                    enemySoldiers.RemoveAt(i);
                    anyEnemyDefeated = true;
                }
            }

            return anyEnemyDefeated;
        }
    }

    public class Fighter
    {
        public Fighter(int health, int armor)
        {
            Damage = GenerateRandomDamage();
            Health = health;
            Armor = armor;
        }

        public int Damage { get; private set; }
        public int Health { get; protected set; }
        public int Armor { get; private set; }

        public virtual Fighter Clone()
        {
            return new Fighter(Health, Armor);
        }

        public virtual string GetName()
        {
            string name = "Боец";
            return name;
        }

        public virtual bool Attack(List<Fighter> enemySoldiers)
        {
            int opponentIndex = UserUtils.GenerateRandomNumber(enemySoldiers.Count);
            Fighter opponent = enemySoldiers[opponentIndex];

            int randomDamageHealth = GenerateRandomDamage();
            int randomArmorPenetration = GenerateRandomDamage();
            int totalDamage = randomDamageHealth + randomArmorPenetration;

            opponent.TakeDamage(randomDamageHealth, randomArmorPenetration);
            Console.WriteLine($"Нанесен урон {totalDamage}!");
            Thread.Sleep(2000);

            return opponent.Health <= 0;
        }

        protected virtual int GenerateRandomDamage()
        {
            int minDamage = 1;
            int maxDamage = 20;
            return UserUtils.GenerateRandomNumbers(minDamage, maxDamage + 1);
        }

        public void TakeDamage(int damageHealth, int armorPenetration)
        {
            Health -= damageHealth;
            Armor -= armorPenetration;
            int minimum = 0;

            if (Health < minimum)
            {
                Health = minimum;
            }

            if (Armor < minimum)
            {
                Armor = minimum;
            }
        }
    }

    public class UserUtils
    {
        private static Random s_random = new Random();

        public static int GenerateRandomNumbers(int min, int max)
        {
            return s_random.Next(min, max);
        }

        public static int GenerateRandomNumber(int number)
        {
            return s_random.Next(number);
        }
    }
}
