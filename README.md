# 06_Object_Oriented_Programming_C

**Основы Объектно-Ориентированного Программирования**

Объектно-Ориентированное Программирование (ООП) является одной из наиболее популярных парадигм в мире разработки программного обеспечения. Из других парадигм программирования следует выделить – структурное программирование (основной представитель этого направления – это язык C) и функциональное программирование (к этой группе относятся языки Haskell, F#, Clojure).
Основными строительными элементами ООП являются **классы и объекты**. Для интуитивного понимания этих понятий приведем такой пример: аналогом класса в реальной жизни является чертеж здания или автомобиля, т.е. некоторый шаблон. Объект – это непосредственно реализация класса в виде некоторой сущности, в нашей аналогии – это конкретное здание или конкретный автомобиль, выполненный по чертежу.
Выделяют три основных “столпа” ООП- это инкапсуляция, наследование и полиморфизм.

**Инкапсуляция**

Инкапсуляция предполагает два основных момента:

сокрытие деталей реализации;
связывание данных и методов для их обработки в одном месте.

“Житейским” примером первого аспекта – сокрытия деталей реализации, может служить автомобиль. Вся его сложность скрыта от пользователя, и нет необходимости разбираться в том, как автомобиль работает, чтобы им пользоваться. Связываение данных и методов предполагает, что в рамках одного класса располагаются данные, определяющие некоторые свойства сущности (например, имя и возраст, если сущность – это человек), и методы для их обработки,  получения и изменения.

**Наследование**

Наследование – это концепция, которая предполагает, что один класс может наследовать функции и данные другого класса. Класс, от которого производится наследование называется родительским или базовым классом, класс который наследует – наследником. Отношение между классом наследником и базовым классом можно определить словом “является”.

Например, представим, что у нас есть базовый класс Фигура, и этот класс содержит только одно свойство – Цвет. Тогда про класс Круг – наследник класса Фигура, можно сказать так: Круг “является” Фигурой. Чего нельзя сказать про отношение между Автомобилем и Двигателем, т.е. Автомобиль не является Двигателем. Это означает, что создание иерархии наследования, в которой Автомобиль – это неследник от Двигателя было бы ошибочной (такой тип отношений назвается композиция).

**Полиморфизм**

Говоря про полиморфизм в общем, можно сказать, что это возможность обработки данных разных типов одной и той же функцией. Различают параметрический полиморфизм и ad–hoc полиморфизм. Параметрический полиморфизм предполагает, что один и тот же код в функции может работать с данными разных типов. Ad–hoc полиморфизм предполагает создание различных реализаций функций в зависимости от типа аргумента(ов), при этом их сигнатура (без учета типов входных аргументов) остается одной и той же.

**Классы**

Класс в языке C# объявляется с помощью ключевого слова class перед ним могут стоять несколько модификаторов, после располагается имя класса. Если предполагается, что класс является наследником другого класса или реализует один или несколько интерфейсов, то они отделяются двоеточием от имени класса и перечисляются через запятую.
Внутри себя, класс может содержать *методы, поля и свойства*. Методы похожи на функции из языков группы структурного программирования. Фактически они определяют то, как можно работать с данным классом или объектами класса. Поля – это переменные, связанные с данным классом, а свойства – это конструкции специального вида, которые упрощают работу с полями (в первом приближении такого понимания будет достаточно).

**Модификаторы доступа**

Модификаторы доступа определяют область видимости как непосредственно самого класса, так и его составляющих (поля, свойства, методы).

В C# доступны следующие модификаторы доступа: *public, private, protected, internal, protected internal, private protected*.

**Модификатор public:**

для класса: указывает на то, что класс доступен снаружи из сборки;
для составляющих класса: указывает на то, что они могут быть доступны вне класса, к ним можно получить доступ из любого места в программе.

**Модификатор private:**

для класса: указывает на то, что класс доступен только внутри сборки.
для составляющих класса: указывает на то, что они доступны только внутри класса.
Если модификатор не указан, то будет использован private.

**Конструктор класса**

Конструктор класса – это специальный метод, который вызывается при инициализации объекта с помощью ключевого слова new. Имя конструктора должно совпадать с именем класса, в сигнатуре конструктора не указывается тип возвращаемого значения.
Конструкторов может быть несколько, они должны отличаться по количеству и типу принимаемых аргументов

**Инициализация объектов класса**

Инициализация объекта класса производится с помощью ключевого слова new:

` DemoClass demo = new DemoClass(); ` 

**Методы**

Методом класса называют функцию или процедуру, которая принадлежит классу или объекту. Отличие функции от процедуры в том, что функция возвращает значение, а процедура нет. В общем виде синтаксис объявления метода выглядит следующим образом:

` модификатор(ы) тип_возвращаемого_значения имя_функции(аргументы) `

**Поля**

Поле представляет собой переменную любого типа, объявленную внутри класса. Через модификатор доступа можно управлять уровнем доступа к полю (так же как для методов). Работать с открытыми полями напрямую (поля, которые имеют модификатор public) является плохой практикой. Если необходимо читать и изменять значение какого-либо поля, то лучше это делать через getter’ы и setter’ы – специальные методы-cdjqcndf, которые выполняют эту работу.

**Свойства** 

Основная причина создания getter’ов и setter’ов – это внедрение дополнительной логики, которая может потребоваться перед тем как выдать значение поля или присвоить ему новое значение. Для упрощения процесса решения такой задачи язык C# предлагает альтернативу – Свойства. С точки зрения пользователя класса работа с свойствами похожа на работу с открытыми полями. Но внутри, “под капотом”, это организовано так, что мы можем добавлять логику при чтении и записи.

У свойства есть два ключевых слова – это *get*, оно определяет блок кода, который выполнится при чтении значения свойства, и *set* – выполнится при присвоении значения свойству. Причем, при необходимости, объявить можно только одно из них, например, если у свойства будет только get, то ему нельзя будет присвоить значение, он будет "только для чтения".

**Ключевое слово this**

Ключевое слово this используется внутри класса для ссылки на текущий экземпляр класса. Чаще всего его приходится использовать в методах для доступа к полям класса. 

**Ключевое слово static**

Если метод, поле или свойство имеет модификатор static, то это означает что они принадлежат уровню класса, а не объекту. То есть для работы с соответствующими элементами не нужно создавать экземпляр класса, можно работать напрямую через имя класса. Если класс объявлен с ключевым словом static, то такой класс называют статическим, он обладает следующими особенностями:

*у такого класса все методы должны быть статическими;*
*его нельзя наследовать (класс является запечатанным);*
*класс не может содержать конструкторы экземпляров;*
*нельзя создавать экземпляры таких классов.*

Примером статического класса может быть класс Math из стандартной библиотеки C#.
